diff --git a/glibc-2.33/elf/rtld.c b/glibc-2.33/elf/rtld.c
index 596b6ac3..2ee270d4 100644
--- a/glibc-2.33/elf/rtld.c
+++ b/glibc-2.33/elf/rtld.c
@@ -169,6 +169,78 @@
 strong_alias (__pointer_chk_guard_local, __pointer_chk_guard)
 #endif
 
+#define AFLPT_RTLD 1
+
+#if AFLPT_RTLD
+
+#include <sys/shm.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <dlfcn.h>
+#include <signal.h>
+
+#include <asm/unistd.h>
+#include <unistd.h>
+
+#define FORKSRV_FD 198
+
+#define AFLPT_ENABLE "__AFLPT_ENABLE"
+
+/* We use this additional AFLPT_# AFLPT_#+1 pair to communicate with proxy */
+#define AFLPT_FORKSRV_FD (FORKSRV_FD - 3)
+#define AFLPT_RTLD_SNIPPET do { __pt_start_forkserver(); } while(0)
+
+/* Fork server logic, invoked before we return from _dl_start. */
+
+static void __pt_start_forkserver(void) {
+  int status;
+  pid_t child_pid;
+  static char tmp[4] = {0, 0, 0, 0};
+
+  if (!getenv(AFLPT_ENABLE)) {
+    return;
+  }
+
+  if (write(AFLPT_FORKSRV_FD + 1, tmp, 4) != 4) {
+    _exit(-1);
+  }
+
+  /* All right, let's await orders... */
+  while (1) {
+    /* Whoops, parent dead? */
+    if (read(AFLPT_FORKSRV_FD, tmp, 4) != 4) {
+      _exit(1);
+    }
+
+    child_pid = INLINE_SYSCALL (fork, 0);
+    if (child_pid < 0) {
+      _exit(4);
+    }
+    if (!child_pid) {
+      /* Close descriptors and run free. */
+      close(AFLPT_FORKSRV_FD);
+      close(AFLPT_FORKSRV_FD + 1);
+      return;
+    }
+
+    /* Parent. */
+    if (write(AFLPT_FORKSRV_FD + 1, &child_pid, 4) != 4) {
+      _exit(5);
+    }
+
+    /* Get status. */
+    if (waitpid(child_pid, &status, 0) < 0) {
+      _exit(6);
+    }
+    /* Relay status to proxy. */
+    if (write(AFLPT_FORKSRV_FD + 1, &status, 4) != 4) {
+      _exit(7);
+    }
+  }
+}
+
+#endif /* AFLPT_RTLD */
+
 /* Check that AT_SECURE=0, or that the passed name does not contain
    directories and is not overly long.  Reject empty names
    unconditionally.  */
@@ -588,6 +660,12 @@
 # define ELF_MACHINE_START_ADDRESS(map, start) (start)
 #endif
 
+    /* AFL-PT-START */
+#if AFLPT_RTLD
+    AFLPT_RTLD_SNIPPET;
+#endif
+    /* AFL-PT-END */
+
     return ELF_MACHINE_START_ADDRESS (GL(dl_ns)[LM_ID_BASE]._ns_loaded, entry);
   }
 }
